<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Chain.js by MStumpp</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Chain.js</h1>
        <p>chain.js - add function chaining capability</p>

        <p class="view"><a href="https://github.com/MStumpp/chain.js">View the Project on GitHub <small>MStumpp/chain.js</small></a></p>


        <ul>
          <li><a href="https://github.com/MStumpp/chain.js/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/MStumpp/chain.js/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/MStumpp/chain.js">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>Basic Chaining of function calls</h3>

<pre><code>var Model = function() {};

Model.prototype.func1 = function() {
  return this.c_delay().c_chain(function() {                  
    console.log('func1 processing...');
    this.c_next();
  });
};

Model.prototype.func2 = function() {
  return this.c_delay().c_chain(function() {
    console.log('func2 processing...');
    this.c_next();
  });
};
</code></pre>

<p>Chainify the Model and call the functions:</p>

<pre><code>chainify(Model);

var Obj = new Model();
Obj.func1().func2();
</code></pre>

<p>Prints to console:</p>

<pre><code>func1 has 0 preceding functions edit:134
func2 has 1 preceding functions edit:143
func1 has 1 succeeding functions edit:136
func1 processing... edit:137
func2 has 0 succeeding functions edit:145
func2 processing... 
</code></pre>

<h3>Add asynchronous processing to a chained function call</h3>

<p>Same as above, but func1 looks like this:</p>

<pre><code>Model.prototype.func1 = function() {
  console.log('func1 has ' + this.c_getPredecessors().length + ' preceding functions');
  return this.c_delay().c_chain(function() {   
    console.log('func1 has ' + this.c_getSuccessors().length + ' succeeding functions');
    console.log('func1 processing...');

    var self = this;
    setTimeout(function() {
      self.c_next();
    }, 5000);    
  });
};
</code></pre>

<p>We get the same as above, but have to wait 5 seconds until the setTimeout() callback is fired.</p>

<pre><code>func1 has 0 preceding functions
func2 has 1 preceding functions
func1 has 1 succeeding functions
func1 processing...
-&gt; Wait 5 seconds
func2 has 0 succeeding functions
func2 processing... 
</code></pre>

<p>This above examples demonstrates that chained functions are called in sequential order, as expected.  </p>

<h3>Passing in a callback, call when asynchronous function finishes execution:</h3>

<p>Same as above, but don't forget to pass in the "arguments" array whenever you want to access arguments within the function passed to c_chain() and/or want the callback capability, demonstrated here.</p>

<pre><code>Model.prototype.func1 = function() {
  console.log('func1 has ' + this.c_getPredecessors().length + ' preceding functions');
  return this.c_delay().c_chain(function() {   
    console.log('func1 has ' + this.c_getSuccessors().length + ' succeeding functions');
    console.log('func1 processing...');
    var self = this;
    setTimeout(function() {
      self.c_next();
    }, 5000);    
  }, arguments);
};
</code></pre>

<p>Now, we pass in a callback to func1(). It's called AFTER the internal asynchronous call to setTimeout(). </p>

<pre><code>chainify(Model);

var Obj = new Model();
Obj.func1(function() {
  console.log('func1 processed!');
  this.c_next();
}).func2();
</code></pre>

<p>Prints:</p>

<pre><code>func1 has 0 preceding functions
func2 has 1 preceding functions
func1 has 1 succeeding functions
func1 processing...
-&gt; Wait 5 seconds
func1 processed!
func2 has 0 succeeding functions
func2 processing... 
</code></pre>

<h3>How this works</h3>

<p>For every function to be chained, a new "slave" object is created with the prototype of the "master" object (Model = master object). The body of the current function is attached to this object. Once the setup is done, a setTimeout() of 1 ms, pointing the body of the current function, is instantiated. The object is then passed to the next function in the chain. This function then decides whether to process all previously chained functions or delay their execution by clearing the timer and adding itself to the chain.</p>

<p>If all functions are chained, the timer of the last function isn't cleared, thus initiating processing of the chain containing the functions to be called.</p>

<p>Due to the asynchronous nature of setTimeout(), the execution of your function chain may be postponed. Take the code of the first example shown above and the following code:</p>

<pre><code>chainify(Model);

var Obj = new Model();
Obj.func1().func2();

console.log('chainifying functions is cool!');
</code></pre>

<p>Prints:</p>

<pre><code>chainifying functions is cool!

func1 has 0 preceding functions
func2 has 1 preceding functions
...
</code></pre>

<p>Depending on your use case, this may not be an issue. However, you may either use a callback on your last function (as shown above) or add a call to exec(). </p>

<pre><code>chainify(Model);

var Obj = new Model();
Obj.func1().func2();

console.log('chainifying functions is cool!');
</code></pre>

<p>Prints:</p>

<pre><code>func1 has 0 preceding functions
func2 has 1 preceding functions
...

chainifying functions is cool!
</code></pre>

<p>Happy function chaining :)</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/MStumpp">MStumpp</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>