<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Chain.js by MStumpp</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Chain.js</h1>
        <p>chain.js - add function chaining capability</p>

        <p class="view"><a href="https://github.com/MStumpp/chain.js">View the Project on GitHub <small>MStumpp/chain.js</small></a></p>


        <ul>
          <li><a href="https://github.com/MStumpp/chain.js/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/MStumpp/chain.js/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/MStumpp/chain.js">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>Basic chaining of function calls</h3>

<pre><code>var Model = function() {};

Model.prototype.func1 = function() {
  return this.c_delay().c_chain(function() {                  
    console.log('func1 processing...');
    this.c_next();
  });
};

Model.prototype.func2 = function() {
  return this.c_delay().c_chain(function() {
    console.log('func2 processing...');
    this.c_next();
  });
};
</code></pre>

<p>Chainify() the Model and call the functions:</p>

<pre><code>chainify(Model);

var Obj = new Model();
Obj.func1().func2();
</code></pre>

<p>Console output:</p>

<pre><code>func1 has 0 preceding functions
func2 has 1 preceding functions
func1 has 1 succeeding functions
func1 processing...
func2 has 0 succeeding functions
func2 processing... 
</code></pre>

<p>Currently, you may use "this.manager.base" within the function handed over to c_chain() the access "Obj".</p>

<h3>Add asynchronous processing to a chained function call</h3>

<p>Same as above, but func1() looks like this:</p>

<pre><code>Model.prototype.func1 = function() {
  console.log('func1 has ' + this.c_getPredecessors().length + ' preceding functions');
  return this.c_delay().c_chain(function() {   
    console.log('func1 has ' + this.c_getSuccessors().length + ' succeeding functions');
    console.log('func1 processing...');

    var self = this;
    setTimeout(function() {
      self.c_next();
    }, 5000);    
  });
};
</code></pre>

<p>We get the same console output as above, but have to wait 5 seconds until the setTimeout() callback is fired.</p>

<pre><code>func1 has 0 preceding functions
func2 has 1 preceding functions
func1 has 1 succeeding functions
func1 processing...
-&gt; Wait 5 seconds
func2 has 0 succeeding functions
func2 processing... 
</code></pre>

<p>This previous example demonstrates that chained functions are called in sequential order, as expected.  </p>

<h3>Passing in a callback, call when asynchronous function terminates:</h3>

<p>Same as above, but don't forget to pass in the "arguments" array whenever you want to access arguments within the function passed to c_chain() and/or want the callback capability, which is demonstrated here.</p>

<pre><code>Model.prototype.func1 = function() {
  console.log('func1 has ' + this.c_getPredecessors().length + ' preceding functions');
  return this.c_delay().c_chain(function() {   
    console.log('func1 has ' + this.c_getSuccessors().length + ' succeeding functions');
    console.log('func1 processing...');

    var self = this;
    setTimeout(function() {
      self.c_next();
    }, 5000);    
  }, arguments);
};
</code></pre>

<p>Now, we pass in a callback to func1(). It's called AFTER the internal asynchronous call to setTimeout() has fired and the function terminated. </p>

<pre><code>chainify(Model);

var Obj = new Model();
Obj.func1(function() {
  console.log('func1 processed!');
  this.c_next();
}).func2();
</code></pre>

<p>Console output:</p>

<pre><code>func1 has 0 preceding functions
func2 has 1 preceding functions
func1 has 1 succeeding functions
func1 processing...
-&gt; Wait 5 seconds
func1 processed!
func2 has 0 succeeding functions
func2 processing... 
</code></pre>

<h3>How this works</h3>

<p>For every function to be chained, a new <strong>slave</strong> object is created internally with the prototype of the <strong>master</strong> object (example above: "Model" = "master" object). The core code base of the current function is attached to the slave. Once the setup is done, a <strong>setTimeout() of 1 ms</strong>, pointing the core code base of the current function, is instantiated. </p>

<p>The object is then returned and eventually handed over to the next function. This function then decides whether to process all previously chained functions using <strong>c_process()</strong>, or delay their execution by clearing the timer using <strong>c_delay()</strong> and adding itself to the chain using <strong>c_chain()</strong>. This function may also clear all previously chained functions using <strong>c_clear()</strong>.</p>

<p>Not surprisingly, the timer of the last function isn't cleared, because there simply isn't any subsequent function which could clear the timer. Thus, once the setTimeout fires after 1ms, processing of the chained functions begins. </p>

<p>Due to the asynchronous nature of the setTimeout() function, the execution of the function chain may be postponed. Take the model code of the first example shown above and the following:</p>

<pre><code>chainify(Model);

var Obj = new Model();
Obj.func1().func2();

console.log('chainifying functions is cool!');
</code></pre>

<p>Console output:</p>

<pre><code>chainifying functions is cool!

func1 has 0 preceding functions
func2 has 1 preceding functions
...
</code></pre>

<p>Depending on the use case, this may not be an issue at all. However, you may either prefer to use a callback on the last function or call exec() at the end. </p>

<pre><code>chainify(Model);

var Obj = new Model();
Obj.func1().func2();

console.log('chainifying functions is cool!');
</code></pre>

<p>Prints:</p>

<pre><code>func1 has 0 preceding functions
func2 has 1 preceding functions
...

chainifying functions is cool!
</code></pre>

<p>I am currently investigating alternatives to achieve the latter without actually calling exec().</p>

<p>Happy function chaining :)</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/MStumpp">MStumpp</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>