{"body":"### Basic Chaining of function calls\r\n\r\n```\r\nvar Model = function() {};\r\n    \r\nModel.prototype.func1 = function() {\r\n  return this.c_delay().c_chain(function() {                  \r\n    console.log('func1 processing...');\r\n    this.c_next();\r\n  });\r\n};\r\n  \r\nModel.prototype.func2 = function() {\r\n  return this.c_delay().c_chain(function() {\r\n    console.log('func2 processing...');\r\n    this.c_next();\r\n  });\r\n};\r\n```\r\n\r\nChainify the Model and call the functions:\r\n\r\n```\r\nchainify(Model);\r\n\r\nvar Obj = new Model();\r\nObj.func1().func2();\r\n```\r\n\r\nPrints to console:\r\n\r\n```\r\nfunc1 has 0 preceding functions edit:134\r\nfunc2 has 1 preceding functions edit:143\r\nfunc1 has 1 succeeding functions edit:136\r\nfunc1 processing... edit:137\r\nfunc2 has 0 succeeding functions edit:145\r\nfunc2 processing... \r\n```\r\n\r\n### Add asynchronous processing to a chained function call\r\n\r\nSame as above, but func1 looks like this:\r\n\r\n```\r\nModel.prototype.func1 = function() {\r\n  console.log('func1 has ' + this.c_getPredecessors().length + ' preceding functions');\r\n  return this.c_delay().c_chain(function() {   \r\n    console.log('func1 has ' + this.c_getSuccessors().length + ' succeeding functions');\r\n    console.log('func1 processing...');\r\n\r\n    var self = this;\r\n    setTimeout(function() {\r\n      self.c_next();\r\n    }, 5000);    \r\n  });\r\n};\r\n```\r\n\r\nWe get the same as above, but have to wait 5 seconds until the setTimeout() callback is fired.\r\n\r\n```\r\nfunc1 has 0 preceding functions\r\nfunc2 has 1 preceding functions\r\nfunc1 has 1 succeeding functions\r\nfunc1 processing...\r\n-> Wait 5 seconds\r\nfunc2 has 0 succeeding functions\r\nfunc2 processing... \r\n```\r\n\r\nThis above examples demonstrates that chained functions are called in sequential order, as expected.  \r\n\r\n### Passing in a callback, call when asynchronous function finishes execution:\r\n\r\nSame as above, but don't forget to pass in the \"arguments\" array whenever you want to access arguments within the function passed to c_chain() and/or want the callback capability, demonstrated here.\r\n\r\n```\r\nModel.prototype.func1 = function() {\r\n  console.log('func1 has ' + this.c_getPredecessors().length + ' preceding functions');\r\n  return this.c_delay().c_chain(function() {   \r\n    console.log('func1 has ' + this.c_getSuccessors().length + ' succeeding functions');\r\n    console.log('func1 processing...');\r\n    var self = this;\r\n    setTimeout(function() {\r\n      self.c_next();\r\n    }, 5000);    \r\n  }, arguments);\r\n};\r\n```\r\n\r\nNow, we pass in a callback to func1(). It's called AFTER the internal asynchronous call to setTimeout(). \r\n\r\n```\r\nchainify(Model);\r\n\r\nvar Obj = new Model();\r\nObj.func1(function() {\r\n  console.log('func1 processed!');\r\n  this.c_next();\r\n}).func2();\r\n```\r\n\r\nPrints:\r\n\r\n```\r\nfunc1 has 0 preceding functions\r\nfunc2 has 1 preceding functions\r\nfunc1 has 1 succeeding functions\r\nfunc1 processing...\r\n-> Wait 5 seconds\r\nfunc1 processed!\r\nfunc2 has 0 succeeding functions\r\nfunc2 processing... \r\n```\r\n\r\n### How this works\r\n\r\nFor every function to be chained, a new \"slave\" object is created with the prototype of the \"master\" object (Model = master object). The body of the current function is attached to this object. Once the setup is done, a setTimeout() of 1 ms, pointing the body of the current function, is instantiated. The object is then passed to the next function in the chain. This function then decides whether to process all previously chained functions or delay their execution by clearing the timer and adding itself to the chain.\r\n\r\nIf all functions are chained, the timer of the last function isn't cleared, thus initiating processing of the chain containing the functions to be called.\r\n\r\nDue to the asynchronous nature of setTimeout(), the execution of your function chain may be postponed. Take the code of the first example shown above and the following code:\r\n\r\n```\r\nchainify(Model);\r\n\r\nvar Obj = new Model();\r\nObj.func1().func2();\r\n\r\nconsole.log('chainifying functions is cool!');\r\n```\r\n\r\nPrints:\r\n\r\n```\r\nchainifying functions is cool!\r\n\r\nfunc1 has 0 preceding functions\r\nfunc2 has 1 preceding functions\r\n...\r\n```\r\n\r\nDepending on your use case, this may not be an issue. However, you may either use a callback on your last function (as shown above) or add a call to exec(). \r\n\r\n```\r\nchainify(Model);\r\n\r\nvar Obj = new Model();\r\nObj.func1().func2();\r\n\r\nconsole.log('chainifying functions is cool!');\r\n```\r\n\r\nPrints:\r\n\r\n```\r\nfunc1 has 0 preceding functions\r\nfunc2 has 1 preceding functions\r\n...\r\n\r\nchainifying functions is cool!\r\n```\r\n\r\nHappy function chaining :)","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Chain.js","tagline":"chain.js - add function chaining capability","google":""}