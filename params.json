{"name":"Chain.js","body":"### Basic chaining of function calls\r\n\r\n```\r\nvar Model = function() {};\r\n    \r\nModel.prototype.func1 = function() {\r\n  return this.c_delay().c_chain(function() {                  \r\n    console.log('func1 processing...');\r\n    this.c_next();\r\n  });\r\n};\r\n  \r\nModel.prototype.func2 = function() {\r\n  return this.c_delay().c_chain(function() {\r\n    console.log('func2 processing...');\r\n    this.c_next();\r\n  });\r\n};\r\n```\r\n\r\nChainify() the Model and call the functions:\r\n\r\n```\r\nchainify(Model);\r\n\r\nvar Obj = new Model();\r\nObj.func1().func2();\r\n```\r\n\r\nConsole output:\r\n\r\n```\r\nfunc1 has 0 preceding functions\r\nfunc2 has 1 preceding functions\r\nfunc1 has 1 succeeding functions\r\nfunc1 processing...\r\nfunc2 has 0 succeeding functions\r\nfunc2 processing... \r\n```\r\n\r\nCurrently, you may use \"this.manager.base\" within the function handed over to c_chain() the access \"Obj\".\r\n\r\n### Add asynchronous processing to a chained function call\r\n\r\nSame as above, but func1() looks like this:\r\n\r\n```\r\nModel.prototype.func1 = function() {\r\n  console.log('func1 has ' + this.c_getPredecessors().length + ' preceding functions');\r\n  return this.c_delay().c_chain(function() {   \r\n    console.log('func1 has ' + this.c_getSuccessors().length + ' succeeding functions');\r\n    console.log('func1 processing...');\r\n\r\n    var self = this;\r\n    setTimeout(function() {\r\n      self.c_next();\r\n    }, 5000);    \r\n  });\r\n};\r\n```\r\n\r\nWe get the same console output as above, but have to wait 5 seconds until the setTimeout() callback is fired.\r\n\r\n```\r\nfunc1 has 0 preceding functions\r\nfunc2 has 1 preceding functions\r\nfunc1 has 1 succeeding functions\r\nfunc1 processing...\r\n-> Wait 5 seconds\r\nfunc2 has 0 succeeding functions\r\nfunc2 processing... \r\n```\r\n\r\nThis previous example demonstrates that chained functions are called in sequential order, as expected.  \r\n\r\n### Passing in a callback, call when asynchronous function terminates:\r\n\r\nSame as above, but don't forget to pass in the \"arguments\" array whenever you want to access arguments within the function passed to c_chain() and/or want the callback capability, which is demonstrated here.\r\n\r\n```\r\nModel.prototype.func1 = function() {\r\n  console.log('func1 has ' + this.c_getPredecessors().length + ' preceding functions');\r\n  return this.c_delay().c_chain(function() {   \r\n    console.log('func1 has ' + this.c_getSuccessors().length + ' succeeding functions');\r\n    console.log('func1 processing...');\r\n\r\n    var self = this;\r\n    setTimeout(function() {\r\n      self.c_next();\r\n    }, 5000);    \r\n  }, arguments);\r\n};\r\n```\r\n\r\nNow, we pass in a callback to func1(). It's called AFTER the internal asynchronous call to setTimeout() has fired and the function terminated. \r\n\r\n```\r\nchainify(Model);\r\n\r\nvar Obj = new Model();\r\nObj.func1(function() {\r\n  console.log('func1 processed!');\r\n  this.c_next();\r\n}).func2();\r\n```\r\n\r\nConsole output:\r\n\r\n```\r\nfunc1 has 0 preceding functions\r\nfunc2 has 1 preceding functions\r\nfunc1 has 1 succeeding functions\r\nfunc1 processing...\r\n-> Wait 5 seconds\r\nfunc1 processed!\r\nfunc2 has 0 succeeding functions\r\nfunc2 processing... \r\n```\r\n\r\n### How this works\r\n\r\nFor every function to be chained, a new **\"slave\"** object is created internally with the prototype of the **\"master\"** object (example above: \"Model\" = \"master\" object). The core code base of the current function is attached to the slave. Once the setup is done, a **setTimeout() of 1 ms**, pointing the core code base of the current function, is instantiated. \r\n\r\nThe object is then returned and eventually handed over to the next function. This function then decides whether to process all previously chained functions using **c_process()**, or delay their execution by clearing the timer using **c_delay()** and adding itself to the chain using **c_chain()**. This function may also clear all previously chained functions using **c_clear()**.\r\n\r\nNot surprisingly, the timer of the last function isn't cleared, because there simply isn't any subsequent function which could clear the timer. Thus, once the setTimeout fires after 1ms, processing of the chained functions begins. \r\n\r\nDue to the asynchronous nature of the setTimeout() function, the execution of the function chain may be postponed. Take the model code of the first example shown above and the following:\r\n\r\n```\r\nchainify(Model);\r\n\r\nvar Obj = new Model();\r\nObj.func1().func2();\r\n\r\nconsole.log('chainifying functions is cool!');\r\n```\r\n\r\nConsole output:\r\n\r\n```\r\nchainifying functions is cool!\r\n\r\nfunc1 has 0 preceding functions\r\nfunc2 has 1 preceding functions\r\n...\r\n```\r\n\r\nDepending on the use case, this may not be an issue at all. However, you may either prefer to use a callback on the last function or call exec() at the end. \r\n\r\n```\r\nchainify(Model);\r\n\r\nvar Obj = new Model();\r\nObj.func1().func2();\r\n\r\nconsole.log('chainifying functions is cool!');\r\n```\r\n\r\nPrints:\r\n\r\n```\r\nfunc1 has 0 preceding functions\r\nfunc2 has 1 preceding functions\r\n...\r\n\r\nchainifying functions is cool!\r\n```\r\n\r\nI am currently investigating alternatives to achieve the latter without actually calling exec().\r\n\r\nHappy function chaining :)","tagline":"chain.js - add function chaining capability","note":"Don't delete this file! It's used internally to help with page regeneration.","google":""}